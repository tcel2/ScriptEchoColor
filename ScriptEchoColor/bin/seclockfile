#!/bin/bash
# Copyright (C) 2004-2012 by Henrique Abdalla
#
# This file is part of ScriptEchoColor.
#
# ScriptEchoColor simplifies Linux terminal text colorizing, formatting 
# and several steps of script coding.
#
# ScriptEchoColor is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# ScriptEchoColor is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with ScriptEchoColor. If not, see <http://www.gnu.org/licenses/>.
#
# Homepage: http://scriptechocolor.sourceforge.net/
# Project Homepage: https://sourceforge.net/projects/scriptechocolor/


strFile="$1"

if [[ -z "$strFile" ]] || [[ "$strFile" == "--help" ]]; then
  echo -e "$0(pid $$)\a" >/dev/stderr
  echo " IMPORTANT: prefer using funcMisc.sh->SECFUNCfileLock(); `basename $0` will deprecate some day..."
  echo "  Parameters: <[PATH/]FILENAME>" >/dev/stderr
  echo "  A file named \"[PATH/]FILENAME.lock\" will be created." >/dev/stderr
  echo >/dev/stderr
  echo "  Usage:" >/dev/stderr
  echo "    strFileLock=\`$0 \$strFile\`;nRet=\$?" >/dev/stderr
  echo "    if((\$nRet!=0));then ...; fi  # could not lock file"
  echo "    ...your code..." >/dev/stderr
  echo "    rm -f \"\$strFileLock\"" >/dev/stderr
  exit 1
fi

strFileLock="$strFile.lock"

if [[ ! -a "$strFile" ]]; then
  echo "$0(pid $$): WARNING: file \"$strFile\" does not exist, skipping lock file \"$strFileLock\" creation." >/dev/stderr
  exit 1
fi

FUNCcreateFile(){
  local strFile="$1"
  local strFileExists=""
  
  # 2nd verify if file exists
  # This is a 'trick' to identify if file already exists and at the 'same time' create a new if it dont exists :).
  # If file exists, 'cp -i' output a question, and output nothing, also create a file, if it dont exists.
  echo -n >>"$strFile.tmp" #temporary file to be copied
  strFileExists=`echo n |cp -i $strFile.tmp $strFile 2>&1`
  rm -f "$strFile.tmp"
  if [[ -n "$strFileExists" ]]; then
    return 1
  fi
  return 0
  
  #@@@??? on failure (($? != 0)), add a test to verify if user has permission to create a file in the folder?
}

FUNClockfile(){
  # this works as: lockfile -1 -r 3 "$strLockFile"
  local strLockFile="$1"
  local nRet=0
  local nRetry=0
  
  for((nRetry=3;nRetry>0;nRetry--));do
    if [[ ! -a "$strLockFile" ]]; then # verify if file exists
      FUNCcreateFile "$strLockFile" 2>&1 >/dev/null # redirects both stdout and stderr to null output :) means 'nothing will be output'
      if(($?==0));then
        return 0
      fi
##      nRet=$?
##      if((nRet==0));then return 0; fi
    fi
    sleep 1
  done
  
  return 73 #retries limit reached
}

# obs.: total wait time is 12 seconds (nCount*'lockfile -r VALUE')
nCount=0
nPID=0
while true; do 
  if((nCount >= 4)); then
    echo -e "$0(pid $$): PROBLEM: while trying to lock file \"$strFile\" with file \"$strFileLock\"\a" >/dev/stderr
    echo "PID $nPID is running (see \"ps -p $nPID\" output):" >/dev/stderr
    ps -p $nPID >/dev/stderr
    echo -n "Remove '$strFileLock' by force and continue running (y/...)? " >/dev/stderr; read -n 1 strResp; echo >/dev/stderr
    if [[ "$strResp" == "y" ]]; then
      rm -f "$strFileLock"
      nCount=0
      continue
    fi
    exit 1
  fi
  ((nCount++))
  
  #lockfile gives problems with filesystem vfat as it tryes to chmod file.lock to readonly
  #lockfile -1 -r 3 "$strFileLock" 2>&1 >/dev/null # redirects both stdout and stderr to null output :) means 'nothing will be output'
  FUNClockfile "$strFileLock"
  nRet=$?
  
  if ((nRet==73)); then # normal problem is just retries limit has been reached
    nPID=0
    strPID=""
    
    bLockFound=false
    if [[ -f "$strFileLock" ]]; then
	    strPID=`cat "$strFileLock"`
	    bLockFound=true
    fi
    
    bValid=true
    if [[ -z "$strPID" ]] || [[ -n `echo "$strPID" |tr -d "[:digit:]"` ]]; then # has non digit
      bValid=false
    else
      nPID=$((strPID))
# This is not neccessary as ps will verify range and output error to /dev/stderr so no problem :)      
#      if ((nPID < 1)) || ((nPID > 2147483647)); then # only digit but out of range
#        bValid=false
#      fi
    fi
    
    if ! $bValid; then
    	if $bLockFound; then
	      echo "$0(pid $$): PROBLEM: invalid PID \"$strPID\" stored at file \"$strFileLock\", removing it by force." >/dev/stderr
	      rm -f "$strFileLock"
	    fi
      nCount=0
      continue
    fi
    
    if ! ps -p $nPID 2>&1 >/dev/null; then # positive part of signed long int value (4 bytes)
      echo "$0(pid $$): WARNING: PID $nPID isn't running, removing \"$strFileLock\"." >/dev/stderr
      rm -f "$strFileLock"
    fi
    continue
  elif ((nRet != 0)); then
    ##@@@r this wont be reached anymore apparently
    echo "$0(pid $$): ERROR: lockfile exit with not expected value \"$nRet\", quiting." >/dev/stderr
    exit 1
  fi
  break
done
  
# save PID at lock file
chmod u+w          "$strFileLock"
echo   -n "$PPID" >"$strFileLock"
chmod  -w          "$strFileLock"

echo "$strFileLock"
